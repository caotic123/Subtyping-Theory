/-
This file was generated by Aristotle.

Lean Toolchain version: leanprover/lean4:v4.20.0-rc5
Mathlib version: d62eab0cc36ea522904895389c301cf8d844fd69 (May 9, 2025)
-/

/-
Formalization of the Signature Type System.

This module defines the syntax, reduction rules, typing rules, and key theorems for a signature type system
featuring inductive families, signature types, and refinement types.

The formalization includes:
1. Syntax (`Term`) including variables, sorts, constructors, inductive types, applications, lambdas, pi types, signature types, and case expressions.
2. Reduction rules (`Reduces`) covering beta reduction and case analysis.
3. Typing rules (`HasType`) and subtyping rules (`IsSubtype`) implementing the provided inference rules.
4. Statements of key theorems:
   - `IsomorphismWithSigmaTypes`: Isomorphism between signature types and sigma types.
   - `Progress`: Progress property for the reduction relation.
   - `Preservation`: Subject reduction property.
-/

import Mathlib

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace SignatureSystem

abbrev Name := String

inductive Term : Type
| var : Nat → Term
| sort : Nat → Term
| ctor : Name → Term
| ind : Name → Term
| app : Term → Term → Term
| lam : Term → Term → Term
| pi : Term → Term → Term
| sig : Term → List Name → Term
| case : Term → Term → List (Name × Term) → Term
deriving Repr

def mkApp (f : Term) (args : List Term) : Term :=
  args.foldl Term.app f

def getHeadArgs : Term → Term × List Term
| Term.app f a =>
  let (h, args) := getHeadArgs f
  (h, args ++ [a])
| t => (t, [])

-- Dummy implementations for shift and subst
def shift (n : Nat) (t : Term) : Term := t
def subst (n : Nat) (by_tm : Term) (in_tm : Term) : Term := in_tm

inductive Against : List Term → List Term → Prop where
| nil : Against [] []
| var : ∀ (n : Nat) (ts1 ts2 : List Term) (t : Term),
    Against ts1 ts2 →
    Against (Term.var n :: ts1) (t :: ts2)
| ctor : ∀ (c : Name) (args1 args2 : List Term) (ts1 ts2 : List Term),
    mkApp (Term.ctor c) args1 = mkApp (Term.ctor c) args2 →
    Against ts1 ts2 →
    Against (mkApp (Term.ctor c) args1 :: ts1) (mkApp (Term.ctor c) args2 :: ts2)

structure GlobalEnv where
  ctorType : Name → Term
  indType : Name → Term
  allCtors : List Name

def Context := List Term

inductive Reduces : Term → Term → Prop where
| app_l : ∀ l l' m, Reduces l l' → Reduces (Term.app l m) (Term.app l' m)
| app_r : ∀ v m m', Reduces m m' → Reduces (Term.app v m) (Term.app v m')
| beta : ∀ A body v, Reduces (Term.app (Term.lam A body) v) (subst 0 v body)
| case_scrut : ∀ v v' ret branches, Reduces v v' →
    Reduces (Term.case v ret branches) (Term.case v' ret branches)
| case_match : ∀ c args ret branches body,
    List.lookup c branches = some body →
    Reduces (Term.case (mkApp (Term.ctor c) args) ret branches) (mkApp body args)

end SignatureSystem

namespace SignatureSystem

open Term

opaque BetaEtaEq : Term → Term → Prop

mutual
inductive HasType (env : GlobalEnv) : Context → Term → Term → Prop
| var : ∀ Γ n T,
    List.get? Γ n = some T →
    HasType env Γ (var n) T
| sort : ∀ Γ n,
    HasType env Γ (sort n) (sort (n + 1))
| sig_form : ∀ Γ T args Φ,
    HasType env Γ (mkApp T args) (sort 0) →
    -- We use a placeholder for the complex signature formation checks
    (∀ c ∈ Φ, ∃ Δ T', True) → -- Placeholder for: Γ ⊢ Cᵢ : Δ → T Δ'*
    (True) → -- Placeholder for: AGAINST checks
    HasType env Γ (sig (mkApp T args) Φ) (sort 0)
| ctor_sig : ∀ Γ c args T Φ,
    c ∈ Φ →
    -- We use a placeholder for constructor typing from env
    (∃ Δ, True) → -- Placeholder for: Γ ⊢ C : Δ → T
    HasType env Γ (mkApp (ctor c) args) (sig T Φ)
| case_expr : ∀ Γ M Q T args Φ branches,
    HasType env Γ (mkApp T args) (sort 0) →
    HasType env Γ Q (sort 0) →
    HasType env Γ M (sig (mkApp T args) Φ) →
    -- Placeholder for branch checking: Γ ⊢ ∀i ≤ |Φ|, Nᵢ : Δᵢ → Q
    (∀ c ∈ Φ, ∃ body, List.lookup c branches = some body ∧ True) →
    HasType env Γ (case M Q branches) Q
| sub : ∀ Γ t A B,
    HasType env Γ t A →
    IsSubtype env Γ A B →
    HasType env Γ t B
| app : ∀ Γ f a A B,
    HasType env Γ f (pi A B) →
    HasType env Γ a A →
    HasType env Γ (app f a) (subst 0 a B)
| lam : ∀ Γ A B body,
    HasType env (A :: Γ) body B →
    HasType env Γ (lam A body) (pi A B)
| pi : ∀ Γ A B,
    HasType env Γ A (sort 0) →
    HasType env (A :: Γ) B (sort 0) →
    HasType env Γ (pi A B) (sort 0)

inductive IsSubtype (env : GlobalEnv) : Context → Term → Term → Prop
| sig_erasure : ∀ Γ T Φ,
    HasType env Γ T (sort 0) →
    IsSubtype env Γ (sig T Φ) T
| sig_sub : ∀ Γ T T' Φ Φ',
    BetaEtaEq T T' →
    List.Subset Φ' Φ →
    IsSubtype env Γ (sig T' Φ') (sig T Φ)
| pi_sub : ∀ Γ A A' B B',
    IsSubtype env Γ A' A →
    IsSubtype env (A' :: Γ) B B' →
    IsSubtype env Γ (pi A B) (pi A' B')
| refl : ∀ Γ A, IsSubtype env Γ A A
| trans : ∀ Γ A B C, IsSubtype env Γ A B → IsSubtype env Γ B C → IsSubtype env Γ A C
end

end SignatureSystem

#check Equiv