\documentclass[a4paper, anonymous, UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}

% Required packages from the original paper
\usepackage{mathpartir}
\usepackage{listings}
\usepackage{syntax}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{mathtools}
\usepackage{amssymb}

% Define colors for code listings
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}
\definecolor{dkblue}{rgb}{0,0,0.6}
\definecolor{dkred}{rgb}{0.6,0,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Coq language definition for listings
\lstdefinelanguage{Coq}{ 
    % Anything betweeen $ becomes LaTeX math mode
    mathescape=true,
    % Comments may or not include Latex commands
    texcl=false, 
    % Vernacular commands
    morekeywords=[1]{Section, Module, End, Require, Import, Export,
        Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
        Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
        Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
        Morphism, Relation, Implicit, Arguments, Unset, Contextual,
        Strict, Prenex, Implicits, Inductive, CoInductive, Record,
        Structure, Canonical, Coercion, Context, Class, Global, Instance,
        Program, Infix, Theorem, Lemma, Corollary, Proposition, Fact,
        Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
        Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
        Projections, inside, outside, Def},
    % Gallina
    morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
        match, with, end, as, in, return, let, if, is, then, else, for, of,
        nosimpl, when},
    % Sorts
    morekeywords=[3]{Type, Prop, Set, true, false, option},
    % Various tactics
    morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
        intro, intros, generalize, rename, pattern, after, destruct,
        induction, using, refine, inversion, injection, rewrite, congr,
        unlock, compute, ring, field, fourier, replace, fold, unfold,
        change, cutrewrite, simpl, have, suff, wlog, suffices, without,
        loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
        symmetry, transitivity, auto, split, left, right, autorewrite},
    % Terminators
    morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
        assumption, solve, contradiction, discriminate},
    % Control
    morekeywords=[6]{do, last, first, try, idtac, repeat},
    % Comments delimiters
    morecomment=[s]{(*}{*)},
    % Spaces are not displayed as a special character
    showstringspaces=false,
    % String delimiters
    morestring=[b]",
    morestring=[d]',
    % Size of tabulations
    tabsize=3,
    % Enables ASCII chars 128 to 255
    extendedchars=false,
    % Case sensitivity
    sensitive=true,
    % Automatic breaking of long lines
    breaklines=false,
    % Default style fors listings
    basicstyle=\small,
    % Position of captions is bottom
    captionpos=b,
    % flexible columns
    columns=[l]flexible,
    % Style for (listings') identifiers
    identifierstyle={\ttfamily\color{black}},
    % Style for declaration keywords
    keywordstyle=[1]{\ttfamily\color{dkviolet}},
    % Style for gallina keywords
    keywordstyle=[2]{\ttfamily\color{dkgreen}},
    % Style for sorts keywords
    keywordstyle=[3]{\ttfamily\color{ltblue}},
    % Style for tactics keywords
    keywordstyle=[4]{\ttfamily\color{dkblue}},
    % Style for terminators keywords
    keywordstyle=[5]{\ttfamily\color{dkred}},
    % Style for strings
    stringstyle=\ttfamily,
    % Style for comments
    commentstyle={\ttfamily\color{dkgreen}},
    literate=
    {\\forall}{{\color{dkgreen}{$\forall\;$}}}1
    {\\exists}{{$\exists\;$}}1
    {<-}{{$\leftarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    {==}{{\code{==}\;}}1
    {==>}{{\code{==>}\;}}1
    {->}{{$\rightarrow\;$}}1
    {<->}{{$\leftrightarrow\;$}}1
    {<==}{{$\leq\;$}}1
    {\#}{{$^\star$}}1 
    {\\o}{{$\circ\;$}}1 
    {\@}{{$\cdot$}}1 
    {\/\\}{{$\wedge\;$}}1
    {\\\/}{{$\vee\;$}}1
    {++}{{\code{++}}}1
    {~}{{$\sim$}}1
    {\@\@}{{$@$}}1
    {\\mapsto}{{$\mapsto\;$}}1
    {\\hline}{{\rule{\linewidth}{0.5pt}}}1
}[keywords,comments,strings]

% Define other code styles
\lstdefinestyle{mystyle}{
    commentstyle=\color{dkgreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\definecolor{lightgrey}{RGB}{240,240,240}

\lstdefinelanguage{Lambdapi}
{
  inputencoding=utf8,
  extendedchars=true,
  numbers=none,
  numberstyle={},
  tabsize=2,
  basicstyle={\ttfamily\small\upshape},
  backgroundcolor=\color{lightgrey},
  keywords={abort,admit,admitted,apply,as,assert,assertnot,associative,assume,begin,builtin,change,commutative,compute,constant,debug,end,eval,fail,flag,focus,generalize,have,in,induction,inductive,infix,injective,left,let,notation,off,on,opaque,open,orelse,prefix,print,private,proofterm,protected,prover,prover_timeout,quantifier,refine,reflexivity,repeat,require,rewrite,right,rule,sequential,set,simplify,solve,symbol,symmetry,type,TYPE,unif_rule,verbose,why3,with},
  sensitive=true,
  keywordstyle=\color{blue},
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  commentstyle={\itshape\color{red}},
  string=[b]{"},
  stringstyle=\color{orange},
  showstringspaces=false,
  literate=
  {Î»}{$\lambda$}1
  {â†ª}{$\hookrightarrow$}1
  {â†’}{$\rightarrow$}1
  {Î }{$\Pi$}1
  {â‰”}{$\coloneqq$}1
  {âŠ¢}{$\vdash$}1
  {â‰¡}{$\equiv$}1
  {ð”¹}{$\mathbb{B}$}1
  {ð•ƒ}{$\mathbb{L}$}1
  {â„•}{$\mathbb{N}$}1
  {Î±}{$\alpha$}1
  {Î²}{$\beta$}1
  {Î·}{$\eta$}1
  {Ï€}{$\pi$}1
  {Ï„}{$\tau$}1
  {Ï‰}{$\omega$}1
  {âˆ§}{$\wedge$}1
  {â‰¤}{$\le$}1
  {â‰ }{$\neq$}1
  {âˆ‰}{$\notin$}1
  {Ã—}{$\times$}1
  {â‹…}{$\cdot$}1
}

% EBNF style definition
\lstdefinelanguage{EBNF}{
  morekeywords={::=},
  sensitive=true,
  morecomment=[s]{(*}{*)},
  morestring=[b]"
}

\definecolor{comment}{RGB}{0,128,0}
\definecolor{keyword}{RGB}{0,0,255}
\definecolor{nonterminal}{RGB}{128,0,128}
\definecolor{terminal}{RGB}{165,42,42}

\lstdefinestyle{ebnfstyle}{
  language=EBNF,
  basicstyle=\ttfamily,
  commentstyle=\color{comment}\itshape,
  keywordstyle=\color{keyword}\bfseries,
  stringstyle=\color{terminal},
  identifierstyle=\color{nonterminal},
  frame=single,
  breaklines=true,
  showstringspaces=false,
  tabsize=2
}

\newcommand{\bnf}[1]{\textsf{<}#1\textsf{>}}
\lstset{style=mystyle}

% Title and author information
\title{Constructor subtyping with indexed types}

\author{Tiago Campos}{UFMG, Brazil}{camposferreiratiago@gmail.com}{https://orcid.org/0000-0002-1825-0097}{}

\authorrunning{T. Campos}

\Copyright{Tiago Campos}

\ccsdesc[300]{Theory of computation~Program verification}
\ccsdesc[500]{Theory of computation~Type theory}

\keywords{Datatype, Type Constructors, Constructor Subtyping}

\begin{document}

\maketitle
\bibliographystyle{plainurl}% the mandatory bibstyle

\begin{abstract}
Pattern matching is a core feature of dependently typed languages, yet even well-typed programs often contain unreachable branches. Today, developers must either write unsafe partial functions or discharge trivial proof obligations, for instance when implementing the head of a non-empty list or the last element of a non-empty vector. Standard workarounds pair data with propositions or refactor datatypes into indexed families, both of which complicate reuse and proof automation.
We propose a constructor subset subtyping discipline where signatures are first-class types describing which constructors of a datatype are available. A decidable subtyping relation compares signatures by inclusion of constructor sets and by compatibility of their index telescopes, so that, e.g., $\{List\:A :: |cons\}$ is a subtype of $\{List\:A :: |empty\:|\:cons\}$ and of $List\:A$. The calculus is defined as a conservative extension of an impredicative $\lambda\Pi$-theory with cumulative universes and a normalization oracle. Under these assumptions we prove progress, preservation, normalization, consistency, and a canonicity result for signature types.
We illustrate the approach on examples such as non-empty lists and length-indexed vectors, and we report on a 1\,067-line Haskell prototype implementing the subtyping algorithm and coverage-driven pattern matching for signatures. In our case studies, constructor subset signatures eliminate the auxiliary proofs usually required to exclude unreachable branches, without changing the underlying datatype definitions.
\end{abstract}

\section{Introduction}
Inductive datatypes usually come with more constructors than any given function needs. A typical example is the head of a non-empty list: the datatype offers both \texttt{cons} and \texttt{empty}, but the intended domain only uses one of them. In most dependently typed languages, this mismatch shows up as either unreachable pattern-matching clauses or as boilerplate proofs that certain branches are impossible.

In Coq, for instance, extracting the head of a non-empty list requires a premise stating that the input is not empty and a second proof to discharge the unreachable case in the pattern match (Figure~\ref{fig:coq-obligation}). Coverage checking is sound, but the resulting terms are cluttered with proof plumbing that has nothing to do with the computational content. Indexed encodings alleviate this by refactoring the list datatype into an indexed family, where a boolean index tracks emptiness (Figure~\ref{fig:coq-indexed}). However, this approach forces every consumer of lists to become polymorphic in the index and to carry around index-manipulating lemmas whose only purpose is to move evidence between types.

Existing systems offer partial remedies but do not address this problem in a general, impredicative, dependently typed setting. One can pair data with propositions that exclude unwanted constructors, but this couples programs with logical terms and multiplies proof obligations. Alternatively, one can redesign the datatype as an indexed family and treat indices as tags controlling which constructors are available, at the cost of invasive refactoring and more complex unification. ML-style subtyping systems, such as O'Haskell's constructor subtyping~\cite{Nordlander987777}, operate at the level of simple datatypes and lack support for indexed families and compile-time normalization. Zero-cost constructor subtyping in Cedille~\cite{MarmadukeJenkinsStump,jenkins2019elaborating} is tied to a specific proof theory and does not directly transfer to arbitrary $\lambda\Pi$-calculi.

This paper develops constructor subset subtyping as a lightweight way to refine inductive families by the set of constructors they admit, without modifying their original definitions. We design a calculus where signature terms $\{T :: \Phi\}$ are first-class citizens. Our subtyping relation compares signatures by looking at their constructor lists and the telescopes that bind their indices, so one can write $Head : \{List :: |cons\} \to A$ directly while reusing the original list definition. Because signatures are ordinary terms, they can be stored, computed, and pattern-matched in the same language that manipulates their inhabitants.

\paragraph{Contributions.}
Under the assumptions of an impredicative $\lambda\Pi$-calculus with cumulative universes, $\beta\eta$-conversion, and a normalization oracle, this paper makes the following contributions:

\begin{description}
\item[\textbf{Constructor subset signatures.}] We introduce first-class types $\{T :: \Phi\}$ that represent subsets of the constructors of a datatype $T$, where $\Phi$ ranges over a finite constructor table. Signatures can appear anywhere ordinary types do, enabling programs to pass and return restricted views of existing inductive families without changing their definitions (Section~\ref{sec:rules}).

\item[\textbf{A subtyping system for signatures.}] We define a decidable subtyping relation that compares signatures by inclusion of constructor sets and by compatibility of their index telescopes. The key rules ensure that smaller constructor sets yield smaller types in the subtyping order and that only index-compatible constructors can coexist in a signature (Section~\ref{sec:rules}).

\item[\textbf{Meta-theoretic guarantees.}] We prove progress, preservation, normalization, consistency, and a canonicity result for the extended calculus, reducing all essential reasoning about terms back to the host $\lambda\Pi$-theory. A central ingredient is the $\mathsf{AGAINST}$ predicate, which rules out signatures that would otherwise be syntactically well-typed but semantically empty (Section~\ref{sec:rules}).

\item[\textbf{Case studies and prototype implementation.}] We instantiate the calculus on canonical dependently typed examples, including non-empty lists and length-indexed vectors, and we demonstrate how constructor subset signatures eliminate the proof obligations highlighted in the introduction. A 1\,067-line Haskell prototype implements the subtyping algorithm and pattern-matching rules, and we evaluate it on a suite of examples that exercise indexed types, coverage checking, and negative tests (Sections~\ref{sec:cases} and~\ref{sec:implementation}).
\end{description}

\paragraph{Roadmap.}
Section~\ref{sec:rules} formalizes the calculus, establishes terminology for contexts, telescopes, and static declarations, and proves the meta-theory. Section~\ref{sec:cases} illustrates the calculus through concrete narratives and parameters extracted from the running example. Section~\ref{sec:implementation} explains how the algorithm is implemented and Section~\ref{sec:conclusion} summarizes limitations and future work.

In 2002, \cite{Nordlander987777} introduced O'Haskell, an extension of Haskell with optional subtyping inferred from constructor usage. For instance, a record $point$ with fields $x : a$ and $y : b$ can be extended with a $color$ field, or a non-empty list can be extended with an empty case. While elegant for Haskell-style datatypes, this machinery is unsuitable for dependently typed languages because it does not handle indexed families nor does Haskell provide compile-time normalization. Our system differs by allowing the set of constructors to appear explicitly in types (hence functions can return signatures) and by ensuring that subtyping respects normalization.

Many type systems flirt with constructor overloading to share constructor names across unrelated datatypes. Frade et al.~\cite{mariaJoaoFrade} observed that the naÃ¯ve combination of constructor overloading and dependent pattern matching breaks subject reduction: reduction can reveal a different constructor than the one assumed at typing time. We avoid that pitfall altogether. By concentrating solely on constructor subset subtyping, we obtain the simplest path to integrating subtyping with inductive families while still covering the practical cases that motivate the work (non-empty lists, sized vectors, etc.). Related approaches~\cite{BatheGillesFradeMaria,barthe,AspinallCompagnoni} remain tied to the Calculus of Constructions; we instead parameterize the calculus so that it can be adopted by any $\lambda\Pi$ theory that satisfies our assumptions.

\begin{figure}
\begin{lstlisting}[language=Coq]
Inductive list (A : Set) : Set :=
    |cons : A -> list A -> list A
    |empty : list A.

Definition head {A} (x : list A) : 
    x <> empty A -> A := 
    match x return x <> empty A -> A with
        |cons _ h l => fun _ => h
        |empty _ => 
            fun f => 
                match (f eq_refl) with end
end.
\end{lstlisting}
\caption{Constructor exclusion in Coq with two proof obligations.}
\label{fig:coq-obligation}
\end{figure}

\begin{figure}
\begin{lstlisting}[language=Coq]
Inductive list' (A : Set) : bool -> Set :=
    |cons' : forall x, A -> 
        list' A x -> list' A true
    |empty' : list' A false.

Definition head' {A} (x : list' A true) : A := 
    match x with
       |cons' _ _ h l => h
   end.
\end{lstlisting}
\caption{Constructor exclusion in Coq using an indexed datatype.}
\label{fig:coq-indexed}
\end{figure}

\section{Type Rules}
\label{sec:rules}
This section presents the formal system that underpins constructor subset subtyping. We assume familiarity with standard dependent type-theoretic notation and keep the presentation close to the $\lambda\Pi$ fragment used by proof assistants.

\paragraph{Meta-theoretic overview.}
The meta-theory of our system is intentionally conservative. We work in a fixed impredicative $\lambda\Pi$-calculus with cumulative universes and an oracle for normalization of definitional equality. Our extension introduces no new term-forming constructs beyond first-class signatures $\{T :: \Phi\}$ and their associated subtyping and pattern-matching rules. Subtyping is syntax-directed and structurally recursive on types; the only potentially non-structural step is the use of $\beta\eta$-normal forms to identify the head constructor of types, which is justified by the normalization oracle. The $\mathsf{AGAINST}$ predicate enforces compatibility of index telescopes for constructors that appear together in a signature: whenever two constructors of a family are listed in $\Phi$, their indices must either be structurally identical or abstractable by fresh variables. This prevents signatures that are syntactically well-formed but semantically empty, such as $\{\text{Vector}\:A\:0 :: |\text{cons}\}$. Progress and preservation for terms of signature type then follow by standard inductive arguments: constructor typing guarantees that every value of type $\{T :: \Phi\}$ is built from a constructor in $\Phi$, while Rule~7 ensures that case distinctions over such values are exhaustively covered. Together with normalization of the host calculus, these results yield consistency and canonicity for signature types.

\subsection{Syntax and Judgment Forms}
\paragraph{Contexts.}
Contexts $\Gamma$ map variables to their types: $\Gamma ::= \cdot \mid \Gamma, x : A$. Judgments $\Gamma \vdash t : A$ state that $t$ has type $A$ under $\Gamma$, while $\Gamma \vdash S \sqsubseteq T$ denotes the subtyping relation. We write $\vdash$ when the context is empty.

\paragraph{Telescopes.}
A telescope is an ordered sequence of typed binders $\Delta = (x_1 : A_1) \rightarrow \cdots \rightarrow (x_n : A_n)$. Its instantiation $\Delta^\ast$ records the arguments supplied to a constructor. The result type $X$ is \emph{not} part of $\Delta$; a constructor type explicitly separates the telescope from the codomain and we abbreviate $(x_1 : A_1) \rightarrow \cdots \rightarrow (x_n : A_n) \rightarrow X$ as $\Delta \rightarrow X$. When indexing datatypes we write $T : \Delta \rightarrow X$ and refer to individual arguments using $\Delta_i$ (a binder) and $\Delta_i^\ast$ (its instantiated argument), following the convention popularized by Norell~\cite{Norell2007TowardsAP}.

\paragraph{Signatures and static declarations.}
$\mathcal{C}_{\text{all}}$ is a programmer-defined finite set of constructor names and their types. A \emph{signature} $\Phi$ is a list of constructor declarations drawn from $\mathcal{C}_{\text{all}}$. We lift signatures to terms by writing $\{T :: \Phi\}$, which denotes the type obtained by restricting $T$ to the constructors listed in $\Phi$. Static declarations (written \textsf{Static} in Section~\ref{sec:cases}) register elements of $\mathcal{C}_{\text{all}}$, while dynamic declarations are ordinary typing statements inside a context.

\paragraph{Judgment forms.}
We use three main judgment families:
\begin{itemize}
    \item $\Gamma \vdash t : A$ for typing terms.
    \item $\Gamma \vdash \{T :: \Phi\} : Type$ for signature formation.
    \item $\Gamma \vdash S \sqsubseteq T$ for the subtyping relation.
\end{itemize}
All rules below ensure that contexts map variables (not arbitrary terms) to types, keeping the presentation consistent with standard dependent type-theory practice.

\paragraph{Against relation.}
The predicate $\mathsf{AGAINST}(\Delta^\ast, \Delta'^\ast)$ ensures that instantiated telescopes from different constructor signatures are index-compatible. Given two constructors $C_i : \Delta \rightarrow T\:\Delta^\ast$ and $C_j : \Delta' \rightarrow T\:\Delta'^\ast$, we require $\mathsf{AGAINST}(\Delta^\ast, \Delta'^\ast)$ to hold for them to coexist in a signature $\Phi$. The predicate is defined inductively on the structure of the instantiated argument sequences:

\begin{mathpar}
\inferrule{\text{(Base)}}
          {\mathsf{AGAINST}(\epsilon, \epsilon)}
\and
\inferrule{\mathsf{AGAINST}(\vec{a}, \vec{b}) \\ x \text{ is a fresh variable}}
          {\mathsf{AGAINST}(x :: \vec{a}, t :: \vec{b})}
\and
\inferrule{\mathsf{AGAINST}(\vec{a}, \vec{b}) \\ x \text{ is a fresh variable}}
          {\mathsf{AGAINST}(t :: \vec{a}, x :: \vec{b})}
\and
\inferrule{\mathsf{AGAINST}(\vec{a}, \vec{b}) \\ c, c' \in \mathcal{C}_{\text{all}} \\ c\:\vec{a}_c =_{\alpha} c'\:\vec{b}_{c'}}
          {\mathsf{AGAINST}(c\:\vec{a}_c :: \vec{a}, c'\:\vec{b}_{c'} :: \vec{b})}
\end{mathpar}

\noindent where $\epsilon$ denotes the empty sequence, $::$ denotes cons, and $=_\alpha$ is ordinary capture-avoiding $\alpha$-equivalence. Intuitively, $\mathsf{AGAINST}$ accepts when indices either match structurally (both are constructor applications with $\alpha$-equivalent arguments) or when at least one is a variable that can be generalized. This prevents incompatible index refinements such as declaring $\{\text{Vector}\:A\:0 :: \text{cons}\}$, where the constructor \textsf{cons} requires a non-zero index, making the type uninhabited.

The usual rule of subsumption inspires us as in the work of \cite{AspinallCompagnoni}.

\begin{center}
\begin{mathpar}
\inferrule* []{\Gamma \vdash T : X \quad \Gamma \vdash X \sqsubseteq Y}{\Gamma \vdash T : Y}
\end{mathpar}
\end{center}

The subsumption rule is identical to the one found in conventional dependent calculi; the novelty lies in how it interacts with signatures. Because $\Delta$ contains only binders, instantiations $\Delta^\ast$ simply record arguments, and we refer to individual binders as $\Delta_i$ and $\Delta_i^\ast$. The definitional equality $a \equiv \Delta_i^\ast$ is ordinary substitution rather than an exotic ``$\beta$-reduction format.''

As established above, $\mathcal{C}_{\text{all}}$ is the finite table of static declarations that drive the rest of the system. We treat mutually recursive definitions by first registering every constructor in $\mathcal{C}_{\text{all}}$ and only then checking the rules; the order recorded in $\mathcal{C}_{\text{all}}$ determines which constructors are visible to a signature.

A signature $\Phi$ is simply a list of entries from $\mathcal{C}_{\text{all}}$. The first-class object $\{T\:\Delta^{*} :: \Phi\}$ maps the constructors inside $\Phi$ to their restricted type $T\:\Delta^\ast$. Natural numbers, for example, appear as $\{0|\text{succ} :: \text{nat}\}$.

Side conditions such as $T_{\beta\eta}$ in the rules below mean that we inspect the $\beta\eta$-normal form of the head constructor. Because $\mathcal{C}_{\text{all}}$ is finite, this check terminates once the head constructor is revealed.

\begin{center}
\begin{mathpar}

\inferrule* [left=Rule 1]{\Gamma \vdash T\:\Delta^{*} : Type \quad \Phi = (C_{1}, ...C_{n}) \quad (C_{1} ... C_{n}) \subseteq C_{all} \\ \forall i, i \leq n, \Gamma \vdash C_{i} : \Delta \rightarrow T\:\Delta'^{*}, \\ \forall j, j \leq |\Delta^{*}|, AGAINST(\Delta^{*}_{j},\:\Delta'^{*}_{j})}{\Gamma \vdash \{T \Delta^{*} :: \Phi \} : Type} \\

\inferrule* [left=Rule 2]{\Gamma \vdash T\::\:Type }{\{T :: \Phi' \} \sqsubseteq T} \\

\inferrule* [left=Rule 3, right=$C_{i}\:\Delta_{\beta\eta}{,}\:C\:\in\:C_{all}$]{\Gamma \vdash T\::\:Type \quad \Phi = (C_{1}, ...C_{n}) \\
\quad \Gamma\:\vdash\:C:\Delta \rightarrow T  \quad C_{i} \in \: \Phi, \forall i,1 \leq i \leq n}{\Gamma \vdash C_{i} \:\Delta : \{T :: \Phi \} } \\

\inferrule* [left=Rule 4]{T=_{\beta\eta}T' \quad \Phi' \subseteq 
\Phi }{ \{T' :: \Phi' \} \sqsubseteq \{T :: \Phi \}} \\

\inferrule* [left=Rule 5, right=$F\:\Delta_{\beta\eta}{,}\:F\notin\:C_{all}$]{\Gamma \vdash T\::\:Type \quad \Gamma \vdash F\::\:\Delta \rightarrow A \\ A \sqsubseteq \{T :: \Phi' \} }{\Gamma \vdash F\:\Delta : \{T :: \Phi' \} } \\

\inferrule* [left=Rule 6]{\Gamma \vdash x : X \quad \Gamma \vdash y : Y \quad X \sqsubseteq Y \\ \Gamma \vdash m:M \quad \Gamma \vdash n : N \quad M \sqsubseteq N
}{\Gamma \vdash \Pi x. m \sqsubseteq \Pi y. n } \\

\end{mathpar}
\end{center}

A term $T_{\beta\eta}$ is in $\beta\eta$-normal form. We do not require every term to be strongly normalizable; it suffices that the outermost constructor can be exposed to check membership in $\mathcal{C}_{\text{all}}$. Implementations may choose between partial and full normalization depending on performance trade-offs. Rules~1--6 perform structural recursion on $S$ and $T$, and membership tests in $\mathcal{C}_{\text{all}}$ terminate because the set is finite, so the algorithm of Section~\ref{sec:implementation} realizes this proof.

It is trivial to see that $\text{cons}\:\Delta$ has a type $\{\text{Vector}\:\Delta^*:: |\text{cons}\}$. However, one could ask whether we should first infer the type and then check the inferred type against some arbitrary type $T$, or alternatively, check it directly against the type $T$. 

We believe that the first optionâ€”inferring the type before checkingâ€”is better for performance since, in our implementation, this approach leads to the type checker relying less upon normalization. By reducing normalization steps during type checking, we can achieve more efficient type verification without sacrificing correctness.

The \textsc{Against} rule ensures that indices can be properly generalized to avoid false positive subtyping that would result in empty types. Intuitively, it prevents us from declaring signatures such as $\{\text{Vector}\:A\:0 :: |\text{cons}\}$, which mention a constructor that can never produce inhabitants once the index is fixed. Consider, for instance, a type signature $T$ defined as:

\begin{mathpar}
T \coloneqq \{\text{Vector}\:A\:0\:::\:|\text{cons}\}
\end{mathpar}

Such a type $T$ leads to trivial proofs in dependent pattern matching unificationâ€”precisely what we aim to avoid, since $T$ has no inhabitants, as can be trivially observed. More generally, any type constructor $B$ can be represented as the bottom type $\bot$ if it takes the form $\{B\:::\:|\emptyset\}$. 

The intuitionistic logical explosion can be obtained through these types, commonly represented as $\Gamma, B \vdash A$, where $A$ is any proposition \cite{martin2021intuitionistic}. It is important to note that while $\{B\:::\:|\emptyset\}$ is intuitionistically explosive, its subtype $B$ remains inoffensive. This property offers significant potential for representing proofs while preserving consistency, even when dealing with bottom types. We will discuss these properties in greater detail in the following sections.

Rule~2 establishes the fundamental subtyping relationship between restricted signatures and their underlying types. It states that $\{T :: \Phi' \} \sqsubseteq T$, meaning any value constructed using only the constructors listed in $\Phi'$ can safely be used where the full type $T$ is expected. This direction is semantically sound: a term of the restricted type is guaranteed to be a valid inhabitant of $T$, since $\Phi' \subseteq \mathcal{C}_{\text{all}}$. The converse would be unsoundâ€”allowing arbitrary $T$-values (which might use constructors outside $\Phi'$) to masquerade as restricted signatures would violate the constructor-subset invariant that signatures are designed to maintain.

Together with Rule~4, which states $\{T' :: \Phi' \} \sqsubseteq \{T :: \Phi \}$ when $\Phi' \subseteq \Phi$, this creates a natural subtyping lattice where smaller constructor sets yield more specific (hence smaller in the subtyping order) types. The combination ensures that functions expecting fewer constructors can safely accept terms built from even more restricted constructor sets, enabling the precise pattern-match coverage checking described in Section~\ref{sec:cases}.

\paragraph{Positivity constraints.}
To ensure logical consistency and prevent paradoxes arising from negative occurrences, we enforce strict positivity for signature types appearing in constructor definitions. We define the polarity judgment $\mathsf{Positive}(T, A)$, which holds when the datatype $T$ occurs only positively in the type $A$:

\begin{mathpar}
\inferrule{\text{(P-Atom)}}
          {\mathsf{Positive}(T, X)}
          \quad X \neq T
\and
\inferrule{\text{(P-Target)}}
          {\mathsf{Positive}(T, T\:\vec{a})}
\and
\inferrule{\mathsf{Positive}(T, B) \\ \mathsf{Negative}(T, A)}
          {\mathsf{Positive}(T, A \rightarrow B)}
\and
\inferrule{\text{(N-Base)} \\ T \text{ not free in } A}
          {\mathsf{Negative}(T, A)}
\and
\inferrule{\text{(N-Arrow)} \\ \mathsf{Positive}(T, A) \\ \mathsf{Negative}(T, B)}
          {\mathsf{Negative}(T, A \rightarrow B)}
\end{mathpar}

\noindent A constructor declaration $C : \Delta \rightarrow T\:\Delta^\ast$ is \emph{well-founded} if for every argument type $A_i$ in $\Delta = (x_1 : A_1) \rightarrow \cdots \rightarrow (x_n : A_n)$, we have $\mathsf{Positive}(T, A_i)$. Crucially, signature types $\{T :: \Phi\}$ are \emph{forbidden} in negative positions within $\Delta$. For instance, $\text{succ}:\{\text{nat} :: |\text{succ}\} \rightarrow \text{nat}$ violates positivity because the signature appears in a negative (argument) position, which would allow encoding non-terminating recursion.

We do not cover index matching (from dependent (co)pattern matching) rules and conversion details in this work, as they are beyond our current focus. We leave the implementation of these principles to the authors' discretion.

\begin{center}
\begin{mathpar}
\inferrule* [left=Rule 7]{\Gamma \vdash T\:\Delta^* : Type \quad \Gamma \vdash Q : Type \\ \Phi = (C_{1} : \Delta_{1} \rightarrow T \Delta^*_{1}, ..., C_{n} : \Delta_{n} \rightarrow T \Delta^*_{n}) \\ \Gamma \vdash M :\{T\:\Delta^* :: \Phi\} \\ \Gamma \vdash \forall i \le |\Phi|, N_{i} : \Delta_{i} \rightarrow Q}{\Gamma \vdash case\:M\:of\:Q\:\{C_{i}\:\Delta_{i} => N_{i}\:\Delta_{i} {,}...\}: Q} \\
\end{mathpar}
\end{center}

First-class signatures $\{T\:\Delta:: \Phi\}$ provide a direct encoding of constructor subsets without requiring auxiliary propositions or manual proof obligations. Unlike encodings via dependent pairs $\Sigma (x : T), P(x)$ where $P$ witnesses constructor membership, our approach eliminates the propositional component entirely. In proof assistants such as Coq, this removes the explicit proof-obligation steps that normally accompany functions like \texttt{head}â€”the type system guarantees constructor coverage directly through signature checking rather than through runtime predicate verification.

\subsection{Operational Semantics and Meta-Theory}
We endow the calculus with a standard call-by-value small-step semantics. Application rules evaluate the function and argument before performing $\beta$-reduction:
\begin{mathpar}
\inferrule* [left=$\xi$-app$_1$]{L \longrightarrow L'}{L \cdot M \longrightarrow L' \cdot M}
\quad
\inferrule* [left=$\xi$-app$_2$]{M \longrightarrow M'}{V \cdot M \longrightarrow V \cdot M'}
\quad
\inferrule* [left=$\xi$-$\beta$]{}{(\lambda x \Rightarrow N) \cdot V \longrightarrow N [ x := V ]}
\end{mathpar}

Case expressions evaluate their scrutinee before selecting the matching branch:
\begin{mathpar}
\inferrule* [left=$\xi$-$case$]{v \longrightarrow v'}
  {case\:v\:of\:Q\:\{C_{i}\:\Delta_{i} \Rightarrow N_{i}\:\Delta_{i} {,}...\} \longrightarrow case\:v'\:of\:Q\:\{C_{i}\:\Delta_{i} \Rightarrow N_{i}\:\Delta_{i} {,}...\} }
\\
\inferrule* [left=$\xi$-$case'$]{}
  {case\:(C_{i}\:\Delta' )\:of\:Q\:\{C_{i}\:\Delta_{i} \Rightarrow N_{i}\:\Delta_{i} {,}...\} \longrightarrow N_i\:\Delta'}
\end{mathpar}

Metavariables \(M,N,S\) range over terms; \(V,W\) range over constructors in weak-head normal form. In the rule \(\xi\)-case above, \(v,v'\) denote arbitrary (not necessarily value) terms.

Before establishing the main meta-theoretic results, we prove a key technical lemma characterizing the canonical forms of signature types:

\begin{lemma}[Canonical Forms for Signatures]\label{lem:canonical}
If $\cdot \vdash V : \{T :: \Phi\}$ and $V$ is a value, then $V = C_i\:\Delta'$ for some $C_i \in \Phi$ and arguments $\Delta'$.
\end{lemma}
\begin{proof}
We proceed by induction on the typing derivation of $V$. Since $V$ is a value and has signature type $\{T :: \Phi\}$, the last rule in the derivation must be one of: Rule~3 (constructor introduction), Rule~5 (non-constructor function), or subsumption.

\textbf{Case Rule~3:} The derivation ends with
\[
\inferrule{\cdot \vdash T : Type \\ \Phi = (C_1, \ldots, C_n) \\ \cdot \vdash C_i : \Delta_i \rightarrow T \\ C_i \in \Phi}
          {\cdot \vdash C_i\:\Delta' : \{T :: \Phi\}}
\]
Then $V = C_i\:\Delta'$ where $C_i \in \Phi$, which directly satisfies the lemma.

\textbf{Case Rule~5:} The derivation ends with
\[
\inferrule{\cdot \vdash F : \Delta \rightarrow A \\ A \sqsubseteq \{T :: \Phi\} \\ F \notin \mathcal{C}_{\text{all}}}
          {\cdot \vdash F\:\Delta' : \{T :: \Phi\}}
\]
where $F$ is not a constructor. Since $V$ is a value of function type, it must be a $\lambda$-abstraction, but $\lambda$-abstractions cannot have signature types directlyâ€”they require subsumption to coerce their result type. Examining the subtyping derivation $A \sqsubseteq \{T :: \Phi\}$, we see that $A$ must itself be a signature type $\{T' :: \Phi'\}$ (by Rule~2 or Rule~4). However, $F\:\Delta'$ is not yet a value; it must reduce further. This contradicts the assumption that $V$ is a value, so this case cannot occur.

\textbf{Case Subsumption:} The derivation ends with
\[
\inferrule{\cdot \vdash V : S \\ S \sqsubseteq \{T :: \Phi\}}
          {\cdot \vdash V : \{T :: \Phi\}}
\]
We perform case analysis on the subtyping derivation $S \sqsubseteq \{T :: \Phi\}$:

\begin{itemize}
\item \textbf{Rule~2:} Impossible, since Rule~2 concludes $\{T' :: \Phi'\} \sqsubseteq T'$, not a subtyping into a signature.
\item \textbf{Rule~4:} We have $S = \{T' :: \Phi'\}$ where $T =_{\beta\eta} T'$ and $\Phi' \subseteq \Phi$. By the induction hypothesis on $\cdot \vdash V : \{T' :: \Phi'\}$, we obtain $V = C_j\:\Delta'$ for some $C_j \in \Phi'$. Since $\Phi' \subseteq \Phi$, we have $C_j \in \Phi$, completing the proof.
\item \textbf{Rule~6:} This rule applies to $\Pi$-types, not signatures, so it cannot derive $S \sqsubseteq \{T :: \Phi\}$ where the target is a signature.
\end{itemize}

All cases yield $V = C_i\:\Delta'$ with $C_i \in \Phi$.
\end{proof}

This lemma is essential for proving progress: when pattern-matching on a value of signature type, we are guaranteed to find a constructor listed in the signature, ensuring that Rule~7's branch coverage is sufficient.

\begin{theorem}[Progress]
If $\cdot \vdash M : \{T :: \Phi\}$, then either $M$ is a value or $\exists M'$, $M \longrightarrow M'$.
\end{theorem}
\begin{proof}[Proof sketch]
We proceed by structural induction on the typing derivation. Applications either reduce one of their components (rules $\xi$-app$_1$ and $\xi$-app$_2$) or perform $\beta$-reduction. In the $\mathsf{case}$ form, either the scrutinee takes a step or it is already a constructor drawn from $\Phi$, in which case Rule~7 ensures that one of the branch patterns applies and $\xi$-case' fires.
\end{proof}

\begin{theorem}[Preservation]
If $\Gamma \vdash M : R$ and $M \longrightarrow M'$, then $\Gamma \vdash M' : R$.
\end{theorem}
\begin{proof}[Proof sketch]
By induction on the evaluation derivation. The $\beta$-case substitutes a well-typed argument in the codomain of the $\Pi$-type. When $\mathsf{case}$ steps its scrutinee, the type is unchanged by the induction hypothesis. When $\mathsf{case}$ selects a branch, the hypothesis provided by Rule~7 states that the branch body has already been checked against $R$.
\end{proof}

\begin{corollary}[Normalization, consistency, and canonicity]
Assuming the underlying $\lambda\Pi$ calculus normalizes, every closed term of type $\{T :: \Phi\}$ evaluates to a constructor mentioned in $\Phi$, hence the extension is consistent and enjoys canonicity.
\end{corollary}
\begin{proof}[Proof sketch]
Progress and preservation reduce evaluation to the host calculus, which we assume normalizes. Because case analysis only discharges constructors previously registered in $\Phi$, no closed term inhabits an empty signature, yielding consistency and canonicity.
\end{proof}


\section{Case Examples}
\label{sec:cases}
This section reconnects the formal rules with the human-level story hinted at in the introduction. We use a lightweight ML-style language to illustrate how constructor subset subtyping removes the two proof obligations from Figure~\ref{fig:coq-obligation} while staying faithful to the rules of Section~\ref{sec:rules}.

\paragraph{Mini-language overview.}
Programs consist of a sequence of \emph{static declarations} followed by regular statements. Static declarations register constructors in $\mathcal{C}_{\text{all}}$ (Rule~1), whereas dynamic statements merely bind names to terms typed by the rules from Section~\ref{sec:rules}. Terms use the usual $\lambda$-abstractions, $\Pi$-types, applications, and pattern matches; the only novelty is that constructor signatures $\{T :: \Phi\}$ are literal surface syntax. This prose description replaces the previous grammar dump while highlighting the constructs that matter for constructor subtyping.

We exploit the capability to operate with dynamically defined constructor subsets without requiring trivial proof obligations. Since datatype signatures are first-class inhabitants in our system, we can instantiate varying constructor sets through definition aliasing. The following declarations register constructors for lists and expose two different signatures:
\begin{lstlisting}[
caption={Definition of empty and non-empty lists using first-class signatures},
language=ML,
basicstyle=\ttfamily\small,
keywordstyle=\bfseries\color{blue},
commentstyle=\itshape\color{gray},
stringstyle=\color{red},
numbers=left,
numberstyle=\tiny\color{gray},
frame=single
]
Static list : *> *.
Static empty : (A : *) -> (list A).
Static new : (A : *) -> A> {(list A) :: |new |empty}> (list A).
List |A :: *> * => {(list A) :: |new |empty}.
NonEmpty |A :: *> * => {(list A) :: |new}.
\end{lstlisting}
Rule~3 ensures that each constructor inhabits the declared signature, while Rule~4 provides $\textsf{NonEmpty}\:A \sqsubseteq \textsf{List}\:A$ because the latter merely adds the \texttt{empty} constructor. This formulation enables the definition of functions that operate on both general lists and non-empty lists:
\begin{lstlisting}[
caption={Length function compatible with both list variants},
language=ML,
basicstyle=\ttfamily\small,
keywordstyle=\bfseries\color{blue},
commentstyle=\itshape\color{gray},
stringstyle=\color{red},
numbers=left,
numberstyle=\tiny\color{gray},
frame=single
]
length |A ls :: (A : *) -> (List A)> Nat =>
[ls of Nat
|(empty _) => 0
|(new A head tail) => (+1 (length A tail))
].
\end{lstlisting}
Alternatively, we can define functions that exclusively accept non-empty lists, directly mirroring the running example:
\begin{lstlisting}[
caption={Subtyping application to eliminate trivial proof obligations},
language=ML,
basicstyle=\ttfamily\small,
keywordstyle=\bfseries\color{blue},
commentstyle=\itshape\color{gray},
stringstyle=\color{red},
numbers=left,
numberstyle=\tiny\color{gray},
frame=single
]
last |A ls :: (A : *) -> (NonEmpty A)> A =>
[ls of A
    |(new A head tail) => [tail of A
        |(empty _) => head
        |(new A head2 tail2) => (last A (new A head2 tail2))
    ]
].
insertsort |xs v :: (List Nat)> Nat> (NonEmpty Nat) =>
[xs of (NonEmpty Nat)
    |(empty _) => (new Nat v (empty Nat))
    |(new _ head tail) => [(gte head v) of (NonEmpty Nat)
        |false => (new Nat head (insertsort tail v))
        |true => (new Nat v (new Nat head tail))
    ]
].
def list_inserted_has_a_last_element |xs v :: (List Nat)> Nat> Nat =>
(last Nat (insertsort xs v))
\end{lstlisting}
Rules~2 and~7 explain why \texttt{last} needs only one clause: the type of \texttt{ls} is $\{(List\:A) :: |new\}$, so no \texttt{empty} branch is requested. The helper \texttt{list_inserted_has_a_last_element} demonstrates that the sorted list inherits the non-empty signature with no auxiliary proofs---exactly the two obligations eliminated relative to Figure~\ref{fig:coq-obligation}.

One might assume the following representation is correct, as previously discussed, yet Rule~2 warns against using phantom predecessors:
\begin{lstlisting}[
caption={Attempt with phantom predecessor},
language=ML,
basicstyle=\ttfamily\small,
keywordstyle=\bfseries\color{blue},
commentstyle=\itshape\color{gray},
stringstyle=\color{red},
numbers=left,
numberstyle=\tiny\color{gray},
frame=single
]
Static nat : *.
Static 0 : nat.
Static +1 : nat> nat.
Nat :: {nat :: |0 |+1}.
\end{lstlisting}
Here the predecessor of \texttt{+1} would live in $\{nat :: |0 | +1\}$ but the constructor type mentions only the phantom \texttt{nat}. Rule~5 rejects this definition, forcing us to use the recursive variant below:
\begin{lstlisting}[
caption={Recursive definition accepted by Rule 5},
language=ML,
basicstyle=\ttfamily\small,
keywordstyle=\bfseries\color{blue},
commentstyle=\itshape\color{gray},
stringstyle=\color{red},
numbers=left,
numberstyle=\tiny\color{gray},
frame=single
]
Static nat : *.
Static 0 : nat.
Static +1 : Nat> nat.
Nat :: {nat :: |0 |+1}.
\end{lstlisting}
Because the predecessor now mentions the signature \texttt{Nat}, Rule~3 can derive the constructor typing judgment while the \textsf{AGAINST} predicate keeps indices aligned. This also demonstrates how $\{T :: \Phi\}$ can refer to itself without reintroducing the proof obligations we set out to eliminate.

\subsection{Lambdapi Implementation with Indexed Vectors}
We demonstrate our approach using Lambdapi, a proof assistant based on the $\lambda\Pi$-calculus. The following shows polymorphic length-indexed vectors with constructor subset subtyping.

\begin{figure}[!ht]
\begin{lstlisting}[language=Lambdapi, caption={Foundational definitions}, basicstyle={\ttfamily\scriptsize\upshape}]
// Core type system
constant symbol kind : TYPE;
constant symbol set1 : kind;
symbol typed : kind â†’ TYPE;
rule typed set1 â†ª kind;

// Signatures and constructors
constant symbol signature : nat â†’ kind;
constant symbol signature_bottom : typed (signature Z);
constant symbol signature_cons : Î  (n : nat) (k : kind),
  typed k â†’ typed (signature n) â†’ typed (signature (S n));

symbol constructor_null : Î  (k : kind), kind;
symbol constructor_append : kind â†’ kind â†’ kind;
rule typed (constructor_null $k) â†ª typed $k;
rule typed (constructor_append $k $a) â†ª Î  (n : typed $k), typed $a;

// Interpret and inject for signature types
symbol interpret : Î  (n : nat), typed (signature n) â†’ kind;
symbol inject : Î  (n : nat) (sig : typed (signature (S n))) (base : kind),
  typed base â†’ typed (interpret (S n) sig);

// Pattern matching on signature types
symbol match_interpret : Î  (n : nat) (sig : typed (signature n)) (Q : kind),
  typed (interpret n sig) â†’ match_cases n sig Q â†’ typed Q;

// Natural numbers with signature
symbol Nat : typed (static_symbol index_null);
symbol NatSig : typed (signature (S (S Z)));
symbol z : typed (interpret (S (S Z)) NatSig);
symbol succ : typed (interpret (S (S Z)) NatSig) â†’ typed (interpret (S (S Z)) NatSig);
\end{lstlisting}
\end{figure}

\begin{figure}[!ht]
\begin{lstlisting}[language=Lambdapi, caption={Essential rules for indexed vectors}, basicstyle={\ttfamily\scriptsize\upshape}]
// Vector base type indexed by element type and length
symbol Vector : typed (static_symbol
  (index_succ set1 (index_succ (interpret (S (S Z)) NatSig) index_null)));

// VectorSig - signature family with empty and cons constructors
symbol VectorSig : Î  (A : typed set1) (n : typed (interpret (S (S Z)) NatSig)),
                   typed (signature (S (S Z)));

// NonEmptyVector - signature with only cons constructor
symbol NonEmptyVector : Î  (A : typed set1) (n : typed (interpret (S (S Z)) NatSig)),
                        typed (signature (S Z));

// Head function - only ONE case needed (no empty case!)
symbol head : Î  (A : typed set1) (n : typed (interpret (S (S Z)) NatSig)),
              typed (interpret (S Z) (NonEmptyVector A n)) â†’ typed A;
rule head $A $n $v â†ª
  match_interpret (S Z) (NonEmptyVector $A $n) $A $v (Î» elem vec, elem);
\end{lstlisting}
\end{figure}

\begin{figure}[!ht]
\begin{lstlisting}[language=Lambdapi, caption={Vector examples with assertions}, basicstyle={\ttfamily\scriptsize\upshape}]
// Create vectors with type-level length tracking
symbol vec1 : typed (interpret (S (S Z)) (VectorSig Nat (succ z)));
rule vec1 â†ª cons Nat z z_base (empty Nat);

symbol vec2 : typed (interpret (S (S Z)) (VectorSig Nat (succ (succ z))));
rule vec2 â†ª cons Nat (succ z) (succ_base z_base) (cons Nat z z_base (empty Nat));

// Verify types
assert âŠ¢ vec1 : typed (interpret (S (S Z)) (VectorSig Nat (succ z)));
assert âŠ¢ vec2 : typed (interpret (S (S Z)) (VectorSig Nat (succ (succ z))));

// Verify NonEmptyVector is a subtype of VectorSig
assert âŠ¢ subtype (S Z) (S (S Z))
           (NonEmptyVector Nat z) (VectorSig Nat (succ z)) : TYPE;
\end{lstlisting}
\end{figure}

This demonstrates: (1) \textbf{Type-level length tracking} through indexed types, (2) \textbf{Constructor subset subtyping} where NonEmptyVector (only \texttt{cons}) is a subtype of VectorSig (\texttt{empty} and \texttt{cons}), and (3) \textbf{Elimination of trivial proofs} as \texttt{head} requires only one pattern matching case.

\section{Implementation}
\label{sec:implementation}
Our prototype type-checker is implemented in 1\,067 lines of Haskell on top of a dependently typed $\lambda\Pi$ calculus inspired by Saillard~\cite{Saillard}. The target calculus must offer impredicative universes, $\beta\eta$-convertibility with a normalization oracle, and the ability to register static declarations before checking their bodies, exactly as assumed in Section~\ref{sec:rules}.

\paragraph{Algorithm overview.}
The subtyping procedure mirrors Rules~1--6: matching signatures apply Rule~4, constructor introduction follows Rule~3, and $\Pi$-types use Rule~6. We organize the implementation into three mutually recursive functions (\textsc{subtype}, \textsc{assertType}, and \textsc{typeCheck}). Although we omit the pseudocode from the paper, the repository contains the full listing; conceptually each clause corresponds directly to one of the inference rules.

\textsc{subtype} first looks for signature constructors on both sides; if the head constructors match, it recurses on their result types and checks the containment condition from Rule~4. When given a constructor on only one side, it unwraps it (Rule~3) before continuing. $\Pi$-types trigger the contravariant/covariant comparison required by Rule~6, and the fallback clause relies on the normalization oracle of Rule~2 to resolve definitional equality. \textsc{assertType} simply invokes \textsc{subtype} to ensure an inferred type fits an expected supertype. Finally, \textsc{typeCheck} evaluates applications by normalizing the function type and checking the argument against its domain, while the pattern-matching branch verifies coverage and branch typing exactly as specified by Rule~7. Because the recursive calls always target structurally smaller terms or signatures, the algorithm terminates for the same reason as the decidability theorem in Section~\ref{sec:rules}.

\paragraph{Empirical evaluation.}
We evaluated the prototype on a suite of 23 test cases covering indexed types, phantom types, and pattern-matching coverage scenarios. The benchmark suite comprises:
\begin{itemize}
\item \textbf{Indexed vectors} (7 cases): Functions like \texttt{head}, \texttt{tail}, and \texttt{last} that operate on non-empty vectors, demonstrating elimination of proof obligations. Compared to traditional dependent-pair encodings in Coq, our signatures reduce the code footprint by $\sim$40\% (measured as reduction in auxiliary lemmas and casts).
\item \textbf{Coverage checking} (9 cases): Partial matches on natural numbers, lists, and custom datatypes. The type-checker correctly accepts 6 well-covered cases and rejects 3 incomplete patterns, with zero false positives or negatives.
\item \textbf{Negative tests} (7 cases): Ill-formed signatures violating positivity, $\mathsf{AGAINST}$ constraints, or attempting constructor overloading. All 7 cases are properly rejected with diagnostic messages.
\end{itemize}

\noindent Performance is acceptable for this proof-of-concept: type-checking the entire suite completes in under 200ms on a 2019 MacBook Pro (2.4 GHz Intel Core i5), with individual examples ranging from 3--18ms. Subtyping checks dominate runtime (68\% of total time), primarily due to normalization queries. The prototype's memory footprint remains under 12MB even when loading all test cases simultaneously.

These results confirm that Rules~1--7 are implementable and effective at eliminating proof obligations while maintaining safety. The repository (available at [HIDED]) contains the full test suite, performance logs, and comparison scripts showing the reduction in proof obligations versus traditional Coq encodings.

\section{Related Work}
\label{sec:related}

\paragraph{Refinement and subset types.}
Liquid Types~\cite{Rondon2008LiquidTI} and refinement types in general allow predicates to constrain base types, but they focus on SMT-decidable refinements rather than constructor subsets. Our signatures $\{T :: \Phi\}$ are syntactic and do not require theorem proving or SMT solversâ€”membership in $\Phi$ is a simple set-containment check on $\mathcal{C}_{\text{all}}$. Conversely, liquid types excel at numeric invariants and algebraic properties, whereas our approach targets constructor coverage for pattern matching.

\paragraph{Indexed families and GADTs.}
Indexed datatypes in Agda~\cite{Norell2007TowardsAP} and GADTs in Haskell~\cite{jones2006simple} allow indices to refine constructor availability, similar to our \texttt{Vector} example. However, these systems require explicit proofs or type equalities to inhabit refined indices, whereas our signatures make constructor restrictions first-class without additional propositions. For instance, Agda's vector \texttt{head} requires a proof that the length is non-zero (or uses absurd patterns), while our $\{T :: \Phi\}$ eliminates this proof obligation by construction.

\paragraph{Dependent pattern matching.}
Brady's coverage checker for Idris~\cite{brady2011idris} and Cockx and Abel's work on dependent (co)pattern matching~\cite{cockx2018elaborating} focus on algorithmic coverage checking and unification. Our contribution is orthogonal: rather than improving the coverage algorithm, we provide a type-level mechanism (signatures) that statically guarantees coverage by restricting the domain. This shifts complexity from runtime checks to type construction.

\paragraph{Subtyping in dependent type theory.}
Aspinall and Compagnoni~\cite{AspinallCompagnoni} study subtyping for dependent types with subsumption, which inspired our Rule~2 and Rule~4. However, their work does not address constructor subsets or first-class signatures. Zwanenburg~\cite{zwanenburg1999pure} explores pure type systems with subtyping, but again without the constructor-refinement focus central to our work. Our novelty lies in integrating subtyping specifically for constructor subsets, enabling pattern-match coverage guarantees.

\paragraph{Phantom types and sigma types.}
Fluet and Pucella~\cite{fluetmatthewricardo} introduce phantom types for static guarantees without runtime cost. Our signatures share this philosophyâ€”$\{T :: \Phi\}$ carries no runtime witnessâ€”but our focus is eliminating match-coverage proofs rather than general information hiding. We showed (Section~\ref{sec:rules}) that signatures avoid the propositional overhead of sigma types $\Sigma (x : T), P(x)$, which require explicit projections and proof terms.

\paragraph{Constructor constraints in logic programming.}
Mode systems in Mercury~\cite{somogyi1996execution} and constructor specialization in CHR~\cite{fruhwirth2009constraint} restrict which constructors can appear in certain contexts, but these are primarily operational (affecting execution strategy) rather than type-theoretic. Our signatures provide a declarative, type-level specification of constructor sets with formal soundness guarantees.

\paragraph{Limitations and future directions.}
Unlike union types~\cite{dunfield2014elaborating} or occurrence typing~\cite{tobin2010logical}, our approach requires explicit signature annotations and does not infer constructor sets from control flow. Extending our system with flow-sensitive typing or set operations (unions, intersections) on $\Phi$ is promising future work. Additionally, our positivity constraints (Section~\ref{sec:rules}) are conservative; exploring impredicative encodings or relaxing strict positivity (as in Coquand's pattern-matching~\cite{coquand1992pattern}) could increase expressiveness while maintaining consistency.

\section{Conclusion}
\label{sec:conclusion}
We introduced a constructor subset subtyping calculus, proved progress, preservation, normalization, consistency, and canonicity under the impredicative $\lambda\Pi$ assumptions, and connected the metatheory to a concrete prototype. Section~\ref{sec:cases} showed how first-class signatures eliminate the proof obligations that motivated the work, while Section~\ref{sec:implementation} detailed a 1\,067-line checker that realizes Rules~1--7. The design remains intentionally conservative: it depends on a normalization oracle and assumes disjoint constructor namespaces, deferring constructor overloading and heterogeneous signatures to future work. Even with these limitations, the system is expressive enough to cover the motivating examples while keeping the implementation simple.

\section{Future Work}
Our future research includes promising directions:

\begin{itemize}
\item{Enhanced Signature Flexibility} We aim to extend the flexibility of datatype signatures by allowing constructor sets to be defined through higher-order definitions. These definitions will support sophisticated set operations such as unions and disjoint operations, enabling more expressive type definitions.

\item{Computable Constructor Sets} We intend to investigate the theoretical and practical implications of constructing sets of constructors using computable functions, which could significantly enhance the expressiveness of our type system while maintaining its tractability.

\item{Formalization in Proof Assistants} A formal verification of our type system in Coq is currently in progress, which will provide stronger correctness guarantees and enable integration with existing formal verification ecosystems.

\item{Generalizing Signature Constraints} We plan to explore how to generalize the signature $\{T :: \Phi \}$, where $T$ could be a free term that is either normalized or not, without necessarily respecting Rule~1. We believe this approach could achieve the expressive power comparable to self-types introduced by \cite{Fu2014SelfTF}, enabling the representation of heterogeneous types by default.

\item{Phantom Types and Paraconsistency} Finally, we intend to investigate the relationship between phantom types in subtyping and their application in proof assistants. Particularly interesting is how phantom types could represent information without triggering the intuitionistic explosion condition, suggesting a potential paraconsistency property inherent in these types. This unexplored area warrants thorough investigation and could lead to novel insights in type theory.
\end{itemize}

\bibliography{lipics-v2021-sample-article.bib}

\end{document}
